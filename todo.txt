

1) Data structure. DB and structure -  Task 1 - Hannes


//DONE
2) logon screen                       
    Usermanagment      
        .env

3) Agree on the styling. - WILL NOT DO.


4) Establish WS connection. - DONE NEED TO UNDERSTAND HOW IT WORKS

how is the data swapped between WS - is there a standard? There is only text and binary
how is the listner configured on input ? 

---


IF the accesskeys are not setup the server should not start! Implement last!

Send data- via WS. ( functions list from -todo)
Retriev data via WS. ( function list from -todo)



Each roll has a UI interface - FE  - we agree on the styling - everybody does one page.
Each roll has BE functionality - BE - we divide up the rolls - everybody does some rolls.


- node js dev vs. regular mode.



Questions:
How to do the front end? 
React Vue, Go and html-templates, something else?
do we do BE and FE separate?
Dockerize the project ( so we do not forget) ?
Use SQLite for data persistance (do we want to use anything else) ?



Mandatory

The README.md file at the root of the project has a user guide, describing the core functionality of the user interfaces


RECEPTIONIST

The receptionist can see a list of upcoming races.
The receptionist can delete an upcoming race.
The README.md file at the root of the project describes how to launch the project.
The receptionist can add new race sessions.
The receptionist can add/edit/remove drivers from a race.
It is not possible to have two drivers with the same name. name is unique 
Race sessions disappear from the Front Desk interface once it is safe to start. // who can make it safe if safe remove fr
The race drivers cannot be edited after the race is safe to start.
The upcoming race session, is displayed on the Next Race display.
The Next Race display switches to the subsequent race, once the current race is safe to start.
The Next Race display shows the drivers names, and the cars they're assigned to.
If there are no upcoming races, no sessions are displayed.
If there is no upcoming race after the last session is ended, the Safety Official sees no upcoming races message.


SAFETY OFFICIAL - AP KARL-HENDRIK


The safety official has one active button, which starts the race when pressed.
When the race is started, the following happens:
- The race mode is changed to "Safe"
- The leader board changes to the current race.
- The Next Race screen switches to the subsequent race session.
- The Safety Official sees race mode controls.


When the Safety Official selects "Safe", the Flag screen is green.
When the Safety Official selects "Hazard", the Flag screen is yellow.
When the Safety Official selects "Danger", the Flag screen is red.
When the Safety Official selects "Finish", the Flag screen is chequered.




When the race mode changes to "Finish", the race controls disappear, and a button appears to end the race session. --This happens when the timer counts down to zero.
When the Safety Official ends the race session, the next session appears on their interface.

When the race session is ended, the Next Race display shows an additional message to proceed to the paddock.
When the race session is ended, the race mode changes to "Danger".

LAP-LINE OBSERVER

When the race session starts, the Lap-Line Observer sees a button for each car.
The lap button for each car has a large tappable area.
The Lap-line Tracker is designed for a tablet, featuring large tappable buttons for each car.
It should work in Landscape or Portrait


-LEADER BOARD

The leaderboard shows the remaining time on the timer.
The leaderboard shows the flag color for the current race mode.
When the lap button is pressed for a car, the leader board is updated.
The countdown timer is 1 minute in dev mode (instead of 10 minutes). -- do the timer logic in the backend. what happens if the race is started and the 

The leaderboard is ordered by fastest lap times
The leaderboard shows the drivers name and car number.
The leaderboard shows the fastest lap time for each car.
The leaderboard shows the current lap for each car.
The first lap starts when the car crosses the leader board for the first time.


SERVER-

The server is written in Node.JS
Communication between interfaces is in real-time. API calls must not be used to send data.
For example, when the race mode is changed by the Safety Official, the flag displays change in real time
Communication between interfaces utilises messages sent via Socket.IO.

NPM START

The server can be started with npm start
The server can be started in developer mode with npm run dev. --The countdown timer runs for 1 minute instead on 10 minutes.

The interfaces are reachable by devices on other networks (not just localhost).
The interfaces must be reachable by devices on other networks. For example, the interface must be reachable from a mobile phone browser, while the server and interfaces are served from a computer.
The Race Control interface is designed for a mobile interface.
The server will not start unless environment variables are set for interface access keys.
The environment variable access codes match the accepted access codes entered into the interfaces.
The Front Desk, Race Control and Lap-line Tracker require access codes to function correctly.
The server waits 500ms to respond if an incorrect access key is entered in the interface.
The interface re-prompts the user to enter a correct access key when an incorrect access key is inserted.

The interfaces are reachable via their correct paths.

| Interface        | Persona           | Route               |
| ---------------- | ----------------- | ------------------- |
| Front Desk       | Receptionist      | `/front-desk`       | get here with the correct login!
| Race Control     | Safety Official   | `/race-control`     | get here with the correct login!
| Lap-line Tracker | Lap-line Observer | `/lap-line-tracker` | get here with the correct login!

| Leader Board     | Guest             | `leader-board`      | <div id = xxx >
| Next Race        | Race Driver       | `next-race`         |  --"--
| Race Countdown   | Race Driver       | `race-countdown`    |  --"--
| Race Flag        | Race Driver       | `race-flags`        |  --"--


The buttons disappear or are visibly disabled between races.
Communication between the interfaces certainly does not use a polling convention.



--

Example Scenario:
Real-time Chat Application: A WebSocket server could manage real-time communication between users.
When a message is sent by one user, the WebSocket server stores it in an SQLite database and immediately broadcasts it 
to other connected users.In summary, while SQLite cannot handle WebSocket connections directly, 
you can use a server application to bridge the gap, allowing WebSocket communication and SQLite database interactions to work together.


Extra
The system state is persisted. --> gets data from the DB in realtime! 

When the server is restarted, the system resumes with the exact same. I.e. the race counter continues counting down, and upcoming races are not lost.

The receptionist can assign drivers to specific cars.